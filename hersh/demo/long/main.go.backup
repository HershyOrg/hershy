package main

import (
	"bufio"
	"fmt"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"hersh"
	"hersh/manager"
)

const (
	// Demo configuration
	DemoName          = "Long-Running Trading Simulator"
	DemoVersion       = "1.0.0"
	TargetDuration    = 4*time.Hour + 30*time.Minute // 4.5 hours
	StatsInterval     = 1 * time.Minute
	RebalanceInterval = 1 * time.Hour
	InitialCapital    = 10000.0 // $10,000 USD
)

func main() {
	fmt.Println(strings.Repeat("‚ïê", 80))
	fmt.Printf("üöÄ %s v%s\n", DemoName, DemoVersion)
	fmt.Println(strings.Repeat("‚ïê", 80))
	fmt.Printf("‚è±Ô∏è  Target Duration: %s\n", TargetDuration)
	fmt.Printf("üìä Stats Interval: %s\n", StatsInterval)
	fmt.Printf("üíº Initial Capital: $%.2f\n", InitialCapital)
	fmt.Println(strings.Repeat("‚ïê", 80))

	// Initialize components outside Watcher
	fmt.Println("\nüîß Initializing components...")

	// Create Binance WebSocket stream
	stream := NewBinanceStream()
	fmt.Println("   ‚úÖ BinanceStream created")

	// Create trading simulator
	simulator := NewTradingSimulator(InitialCapital)
	fmt.Println("   ‚úÖ TradingSimulator created")

	// Create stats collector
	statsCollector := NewStatsCollector()
	fmt.Println("   ‚úÖ StatsCollector created")

	// Create command handler
	commandHandler := NewCommandHandler(stream, simulator, statsCollector)
	fmt.Println("   ‚úÖ CommandHandler created")

	// Connect to Binance WebSocket
	fmt.Println("\nüåê Connecting to Binance WebSocket...")
	if err := stream.Connect(); err != nil {
		fmt.Printf("‚ùå Failed to connect: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("   ‚úÖ Connected to wss://stream.binance.com:9443")

	// Wait for initial prices
	fmt.Println("\n‚è≥ Waiting for initial price data...")
	for range 30 { // Wait up to 3 seconds
		if stream.GetCurrentBTC() > 0 && stream.GetCurrentETH() > 0 {
			fmt.Printf("   ‚úÖ Initial prices received: BTC=$%.2f, ETH=$%.2f\n",
				stream.GetCurrentBTC(), stream.GetCurrentETH())
			break
		}
		time.Sleep(100 * time.Millisecond)
	}

	if stream.GetCurrentBTC() == 0 || stream.GetCurrentETH() == 0 {
		fmt.Println("   ‚ö†Ô∏è  Initial prices not received, continuing anyway...")
	}

	// Create Watcher with long-running configuration
	fmt.Println("\nüîç Creating Hersh Watcher...")
	config := hersh.DefaultWatcherConfig()
	config.DefaultTimeout = 10 * time.Minute // Generous timeout for long operations
	config.RecoveryPolicy.MinConsecutiveFailures = 5
	config.RecoveryPolicy.MaxConsecutiveFailures = 10
	config.RecoveryPolicy.BaseRetryDelay = 10 * time.Second
	config.RecoveryPolicy.MaxRetryDelay = 5 * time.Minute
	config.RecoveryPolicy.LightweightRetryDelays = []time.Duration{
		30 * time.Second,
		1 * time.Minute,
		2 * time.Minute,
	}

	envVars := map[string]string{
		"DEMO_NAME":    DemoName,
		"DEMO_VERSION": DemoVersion,
	}

	watcher := hersh.NewWatcher(config, envVars)
	fmt.Println("   ‚úÖ Watcher created with long-running config")

	// Register managed function
	watcher.Manage(func(msg *hersh.Message, ctx hersh.HershContext) error {
		return mainReducer(msg, ctx, stream, simulator, statsCollector, commandHandler)
	}, "TradingSimulator").Cleanup(func(ctx hersh.HershContext) {
		cleanup(ctx, stream, simulator, statsCollector)
	})

	// Setup signal handling for graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	// Start Watcher
	fmt.Println("\n‚ñ∂Ô∏è  Starting main trading loop...")
	fmt.Println("   Type 'help' for available commands")
	fmt.Println("   Press Ctrl+C to stop")
	fmt.Println()

	if err := watcher.Start(); err != nil {
		fmt.Printf("\n‚ùå Watcher failed to start: %v\n", err)
		os.Exit(1)
	}

	// Start user input handler (only if stdin is available)
	go func() {
		stat, _ := os.Stdin.Stat()
		if (stat.Mode() & os.ModeCharDevice) != 0 {
			// Interactive terminal, handle user input
			handleUserInput(watcher)
		}
	}()

	// Start ticker to keep reducer running (sends empty message every second)
	// This ensures WatchCall intervals can trigger properly
	go func() {
		ticker := time.NewTicker(1 * time.Second)
		defer ticker.Stop()

		for {
			select {
			case <-ticker.C:
				// Send empty message to trigger reducer execution
				watcher.SendMessage("")
			case <-sigChan:
				return
			}
		}
	}()

	// Wait for shutdown signal
	<-sigChan

	// Graceful shutdown
	fmt.Println("\n\nüõë Shutting down...")

	// Print logger summary before stopping
	fmt.Println("\n" + strings.Repeat("‚ïê", 80))
	fmt.Println("üìã EXECUTION LOGS")
	fmt.Println(strings.Repeat("‚ïê", 80))
	watcher.GetLogger().PrintSummary()

	fmt.Println("\n   Stopping Watcher...")
	watcher.Stop()

	fmt.Println("\n‚úÖ Demo completed successfully")
	fmt.Println(strings.Repeat("‚ïê", 80))
}

// mainReducer is the main managed function for the Watcher
func mainReducer(
	msg *hersh.Message,
	ctx hersh.HershContext,
	stream *BinanceStream,
	simulator *TradingSimulator,
	statsCollector *StatsCollector,
	commandHandler *CommandHandler,
) error {
	// DEBUG: Print reducer execution
	fmt.Printf("[DEBUG] mainReducer called at %s\n", time.Now().Format("15:04:05"))

	// Initialize start time on first run
	startTimeVal := ctx.GetValue("start_time")
	if startTimeVal == nil {
		fmt.Println("[DEBUG] Initializing start time and timers")
		ctx.SetValue("start_time", time.Now())
		ctx.SetValue("last_stats_time", time.Now())
		ctx.SetValue("last_rebalance_time", time.Now())
		startTimeVal = time.Now()
	}
	startTime := startTimeVal.(time.Time)

	// Check if demo duration reached
	elapsed := time.Since(startTime)
	if elapsed >= TargetDuration {
		targetReachedVal := ctx.GetValue("target_reached")
		if targetReachedVal == nil {
			fmt.Printf("\nüéØ Target duration reached: %s\n", TargetDuration)
			fmt.Println("   Demo will continue until you press Ctrl+C")
			ctx.SetValue("target_reached", true)
		}
	}

	// Get BTC price using WatchCall instead of WatchFlow
	// WatchCall polls the current price periodically
	btcPriceVal := hersh.WatchCall(
		func() (manager.VarUpdateFunc, error) {
			price := stream.GetCurrentBTC()
			if price == 0 {
				return nil, fmt.Errorf("BTC price not available")
			}

			return func(prev any) (any, bool, error) {
				if prev == nil || prev.(float64) != price {
					return price, true, nil
				}
				return prev, false, nil
			}, nil
		},
		"btc_price",
		100*time.Millisecond, // Check every 100ms
		ctx,
	)
	if btcPriceVal != nil {
		simulator.UpdatePrice("BTC", btcPriceVal.(float64))
	}

	// Get ETH price using WatchCall
	ethPriceVal := hersh.WatchCall(
		func() (manager.VarUpdateFunc, error) {
			price := stream.GetCurrentETH()
			if price == 0 {
				return nil, fmt.Errorf("ETH price not available")
			}

			return func(prev any) (any, bool, error) {
				if prev == nil || prev.(float64) != price {
					return price, true, nil
				}
				return prev, false, nil
			}, nil
		},
		"eth_price",
		100*time.Millisecond, // Check every 100ms
		ctx,
	)
	if ethPriceVal != nil {
		simulator.UpdatePrice("ETH", ethPriceVal.(float64))
	}

	// Watch for stats interval
	statsTickerVal := hersh.WatchCall(
		func() (manager.VarUpdateFunc, error) {
			now := time.Now()
			return func(prev any) (any, bool, error) {
				// Always trigger on the interval
				return now, true, nil
			}, nil
		},
		"stats_ticker",
		StatsInterval,
		ctx,
	)

	// Print stats when triggered
	if statsTickerVal != nil {
		statsCollector.PrintStats(stream, simulator)
		ctx.SetValue("last_stats_time", time.Now())
	}

	// Watch for rebalance interval
	rebalanceTickerVal := hersh.WatchCall(
		func() (manager.VarUpdateFunc, error) {
			now := time.Now()
			return func(prev any) (any, bool, error) {
				// Always trigger on the interval
				return now, true, nil
			}, nil
		},
		"rebalance_ticker",
		RebalanceInterval,
		ctx,
	)

	// Execute rebalance when triggered
	if rebalanceTickerVal != nil {
		fmt.Println("\n‚è∞ Hourly rebalance triggered...")
		trades := simulator.Rebalance()

		if len(trades) > 0 {
			fmt.Printf("   Executed %d rebalancing trades\n", len(trades))
			for _, t := range trades {
				fmt.Printf("      %s %s: %.6f @ $%.2f\n",
					t.Action, t.Symbol, t.Amount, t.Price)
			}
		} else {
			fmt.Println("   No rebalancing needed")
		}

		ctx.SetValue("last_rebalance_time", time.Now())
	}

	// Execute trading strategy (unless paused)
	if !simulator.IsPaused() {
		trades := simulator.ExecuteStrategy()

		if len(trades) > 0 {
			fmt.Printf("\nüíπ Strategy executed %d trades:\n", len(trades))
			for _, t := range trades {
				fmt.Printf("   %s %s %s: %.6f @ $%.2f (%s)\n",
					t.Time.Format("15:04:05"),
					t.Action, t.Symbol, t.Amount, t.Price, t.Reason)
			}

			portfolio := simulator.GetPortfolio()
			fmt.Printf("   Portfolio Value: $%.2f (%.2f%%)\n",
				portfolio.CurrentValue, portfolio.ProfitLossPercent)
		}
	}

	// Handle user messages (commands)
	if msg != nil {
		commandHandler.HandleCommand(msg.Content)
	}

	return nil
}

// cleanup is called when the Watcher stops
func cleanup(
	ctx hersh.HershContext,
	stream *BinanceStream,
	simulator *TradingSimulator,
	statsCollector *StatsCollector,
) {
	fmt.Println("\nüîß Cleanup started...")

	// Close WebSocket
	fmt.Println("   Closing WebSocket...")
	stream.Close()

	// Print final statistics
	fmt.Println("\nüìä Final Statistics:")
	statsCollector.PrintDetailedStats(stream, simulator)

	fmt.Println("\n‚úÖ Cleanup complete")
}

// handleUserInput reads user input and sends to Watcher
func handleUserInput(w *hersh.Watcher) {
	scanner := bufio.NewScanner(os.Stdin)

	for scanner.Scan() {
		input := scanner.Text()
		if input == "" {
			continue
		}

		// Send command to Watcher
		if err := w.SendMessage(input); err != nil {
			fmt.Printf("‚ö†Ô∏è  Failed to send command: %v\n", err)
		}
	}

	if err := scanner.Err(); err != nil {
		fmt.Printf("‚ö†Ô∏è  Input error: %v\n", err)
	}
}
